# Agrex.Schema

## Outline

- [Agrex.Schema](#agrexschema)
  - [Outline](#outline)
  - [Domain Model](#domain-model)

## Domain Model

```mermaid
erDiagram 

    Landscape ||--|{ Region : "at least 1"
    Region ||--|{ Farm : "at least 1"
    Farm ||--|{ Herd : "at least 1"
    Herd ||--|{ Life : "at least 1"
    Farm ||--|{ Field : "at least 1"
    Life ||--o{ Life : "0 or more"
    Life ||--|| Life : "Breeds with one"
    Field }|--|{ Herd : "many to many"
    Farm ||--|{ Stable : "at least 1"
    Stable ||--|{ Robot : "at least 1" 



```
t is quite surprising how limited the adoption of ES/CQRS throughout the industry really is, even if it is the most natural way of implementing reality. 

In essence, reality -or rather, history- is immutable by default. One cannot change the past: the only sane thing to do is record facts as they happen and draw conclusions from it later. That is ES/CQRS in one sentence. There is great value in storing state changes and knowing why a change happened.

The funny - and powerful- thing is, that these conclusions (projections) may vary over time, driven by evolving needs and insights and systems can be optimized towards retrieving this information rapidly. 

Looking at it from that perspective, ES/CQRS should be the default go-to for implementing any serious system, especially when dealing with distribution and concurrency. 

Have a great weekend!
The challenge we still face today, after a quarter of the 21st century has passed, is that many in the industry still gravitate towards a technology that originated in the 80s of the past century, a technology that was intended to save on storage (looking at you, RDBMS) and doesn't seem to care about data loss. (you too, evil CRUD)...We may only hope that one day they stop teaching this monstrosity. Sure, use it to store projections, if you must, but just record the facts on an endless tape you can listen to over and over again. 

Have a great weekend! 

